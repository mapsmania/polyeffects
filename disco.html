<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Polygon Effects</title>
  <link href="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    body { margin:0; background: #070b1a; font-family: sans-serif; }
    #map { height:100vh; width:100vw; }
    #buttons {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      display: flex;
      gap: 10px;
    }
    #buttons button {
      padding: 8px 12px;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.2s;
    }
    #buttons button.active {
      background: #e65100;
      color: white;
      border-color: #bf360c;
    }
  </style>
</head>
<body>

<div id="buttons">
  <button id="btn-presentation">Presentation Mode</button>
</div>

<div id="map"></div>

<!-- Hosted MP3 with CORS -->
<audio id="audio" src="https://yourusername.github.io/repo-name/dance.mp3" controls loop></audio>

<script src="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.js"></script>
<script>
const map = new maplibregl.Map({
  style: 'https://tiles.openfreemap.org/styles/bright',
  center: [13.3881, 52.5171],
  zoom: 18,
  pitch: 60,
  bearing: -20,
  container: 'map'
});

map.on('load', () => {

  const floorHeight = 3;
  const floors = 16;
  const DEFAULT_COLOR = '#6b7e9c';
  let features = [];

  // ---------- CREATE FLOORS ----------
  for (let i = 0; i < floors; i++) {
    features.push({
      type: "Feature",
      id: i,
      properties: {
        base: i * floorHeight,
        height: (i + 1) * floorHeight,
        dynamicColor: DEFAULT_COLOR
      },
      geometry: {
        type: "Polygon",
        coordinates: [[
          [13.3878, 52.5168],
          [13.3884, 52.5168],
          [13.3884, 52.5173],
          [13.3878, 52.5173],
          [13.3878, 52.5168]
        ]]
      }
    });
  }

  map.addSource('floors', {
    type: 'geojson',
    data: { type: "FeatureCollection", features }
  });

  map.addLayer({
    id: 'floor-extrusions',
    type: 'fill-extrusion',
    source: 'floors',
    paint: {
      'fill-extrusion-color': ['get', 'dynamicColor'],
      'fill-extrusion-height': ['get', 'height'],
      'fill-extrusion-base': ['get', 'base'],
      'fill-extrusion-opacity': 0.9
    }
  });

  // ---------- AUDIO SETUP ----------
  const audioElement = document.getElementById('audio');
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const source = audioCtx.createMediaElementSource(audioElement);
  const analyser = audioCtx.createAnalyser();
  source.connect(analyser);
  analyser.connect(audioCtx.destination);
  analyser.fftSize = 256;
  const bufferLength = analyser.frequencyBinCount;
  const dataArray = new Uint8Array(bufferLength);

  let animationFrame = null;
  let audioStarted = false;

  // ---------- CLEAR ----------
  function clearAnimation() {
    if (animationFrame) cancelAnimationFrame(animationFrame);
    animationFrame = null;

    features.forEach((f, i) => {
      f.properties.base = i * floorHeight;
      f.properties.height = (i + 1) * floorHeight;
      f.properties.dynamicColor = DEFAULT_COLOR;
    });
    map.getSource('floors').setData({ type: "FeatureCollection", features });

    document.querySelectorAll('#buttons button').forEach(b => b.classList.remove('active'));
  }

  // ---------- PRESENTATION MODE ----------
  function startPresentationMode() {
    clearAnimation();
    document.getElementById('btn-presentation').classList.add('active');
    if (!audioStarted) {
      audioCtx.resume().then(() => {
        audioElement.play();
        audioStarted = true;
        animatePresentation();
      });
    } else {
      animatePresentation();
    }
  }

  let effectIndex = 0;
  const effects = ['wave', 'scanner', 'fire', 'oscillate'];
  let effectStepTime = 5000; // change effect every 5 seconds
  let lastEffectChange = performance.now();

  let scanner = 0;
  let scannerDir = 1;

  function animatePresentation(time) {
    analyser.getByteFrequencyData(dataArray);

    // Switch effect periodically
    if (time - lastEffectChange > effectStepTime) {
      effectIndex = (effectIndex + 1) % effects.length;
      lastEffectChange = time;
    }

    const effect = effects[effectIndex];

    features.forEach((f, i) => {

      // Map each floor to a frequency bin
      const binIndex = Math.floor((i / floors) * bufferLength);
      const intensity = dataArray[binIndex] / 255;

      // Initialize color & height
      let color = DEFAULT_COLOR;
      let wave = 0;

      switch(effect) {
        case 'wave':
          wave = Math.sin(time*0.003 + i*0.5) * 2 * intensity;
          const rWave = Math.floor(50 + intensity*205);
          const gWave = Math.floor(120 + (i/floors)*135*intensity);
          const bWave = Math.floor(255 - intensity*200);
          color = `rgb(${rWave},${gWave},${bWave})`;
          break;

        case 'scanner':
          // Knight-Rider style
          const distance = Math.abs(i - scanner);
          let intensityScanner = Math.max(0, 1 - distance/4);
          intensityScanner *= intensityScanner; // sharper falloff
          const rScan = Math.floor(150 + intensityScanner*105);
          const gScan = Math.floor(intensityScanner*50);
          const bScan = Math.floor(intensityScanner*50);
          color = `rgb(${rScan},${gScan},${bScan})`;
          wave = Math.sin(time*0.002 + i*0.5) * 1.5 * intensity;
          break;

        case 'fire':
          // Flickering effect
          const flicker = Math.random()*50;
          const rFire = 255;
          const gFire = Math.floor(i/floors*150 + flicker);
          const bFire = 0;
          color = `rgb(${rFire},${gFire},${bFire})`;
          wave = Math.sin(time*0.004 + i*0.5) * 1.2 * intensity;
          break;

        case 'oscillate':
          wave = Math.sin(time*0.002 + i*0.6) * 1.5 * intensity;
          const glow = Math.floor(120 + ((wave+1.5)/3)*135);
          color = `rgb(${glow},${glow},255)`;
          break;
      }

      f.properties.base = i*floorHeight + wave;
      f.properties.height = (i+1)*floorHeight + wave;
      f.properties.dynamicColor = color;

    });

    // Update scanner position
    if (effects[effectIndex] === 'scanner') {
      scanner += scannerDir;
      if (scanner >= floors-1 || scanner <= 0) scannerDir *= -1;
    }

    map.getSource('floors').setData({ type: "FeatureCollection", features });

    animationFrame = requestAnimationFrame(animatePresentation);
  }

  // ---------- BUTTON ----------
  document.getElementById('btn-presentation').addEventListener('click', startPresentationMode);

});
</script>
</body>
</html>
